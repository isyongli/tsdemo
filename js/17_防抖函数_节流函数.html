<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>防抖函数_节流函数</title>
    <script src="./lib/underscore.js"></script>
    <style>
      #test {
        height: 300px;
        background-color: blueviolet;
      }
    </style>
  </head>
  <body>
    <div id="test"></div>
    <script type="text/javascript">
      const log = console.log
      // 防抖函数
      /**
       * 解决什么问题？
       * 1.对于事件被触发n秒后再执行的函数 ->  延迟执行
       * 2.如果在n秒内再触发事件，重新开始计时
       * func 执行函数
       * wait 延时秒数
       * immediate 是否立即执行
       */
      function debounce(func, wait, immediate) {
        let timer = null
        return function () {
          var context = this,
            args = arguments
          if (timer) clearTimeout(timer)
          if (immediate) {
            //是否立即执行(控制执行开关)
            let callNow = !timer
            timer = setTimeout(() => {
              timer = null
            }, wait)
            if (callNow) func.apply(context, args)
          } else {
            // 不立即执行
            timer = setTimeout(() => {
              func.apply(context, args)
            }, wait)
          }
          // log('timer', timer)
        }
      }

      function debounce_test1(func, wait, immediate) {
        let timer
        return function () {
          let context = this,
            args = arguments
          if (timer) clearTimeout(timer)
          if (immediate) {
            const callNow = !timer
            timer = setTimeout(() => {
              timer = null
            }, wait)
            if (callNow) func.apply(context, args)
          } else {
            timer = setTimeout(() => {
              func.apply(context, args)
            }, wait)
          }
        }
      }

      function debounce_test2(func, wait, immediate) {
        let timer
        return function () {
          let context = this,
            args = arguments
          if (timer) clearTimeout(timer)
          if (immediate) {
            let callNow = !timer
            timer = setTimeout(() => {
              timer = null
            }, wait)
            if (callNow) func.apply(context, wait)
          } else {
            timer = setTimeout(() => {
              func.apply(context, args)
            }, wait)
          }
        }
      }

      var test = document.querySelector('#test')
      // test.onmousemove = debounce(
      //   function () {
      //     log('===========')
      //   },
      //   500,
      //   true
      // )
      // log('===test===:', test)

      // 简单的节流函数
      /*/**
       * 持续触发事件，每隔一段时间，只执行一次事件
       */
      function throttle(func, wait) {
        let timer,
          startTime = 0
        return function () {
          let context = this,
            args = arguments
          let nowTime = new Date().valueOf()
          log('nowTime - startTime', nowTime - startTime)
          if (nowTime - startTime > wait) {
            //第一次执行
            log('=====1=====')
            if (timer) {
              clearTimeout(timer)
              timer = null
            }
            func.apply(context, args)
            startTime = nowTime
          } else if (!timer) {
            //最后一次执行
            log('=====2=====')
            timer = setTimeout(() => {
              timer = null
              func.apply(context, args)
              startTime = new Date().valueOf()
            }, wait)
          }
        }
      }
      // test.onmousemove = throttle(function () {
      //   log('===========')
      // }, 500)
      test.onclick = throttle(function () {
        log('===========')
      }, 1000)

      function throttle_test1(func, wait) {
        let timer,
          startTime = 0
        return function () {
          let context = this,
            args = arguments,
            nowTime = new Date().valueOf()
          if (nowTime - startTime > wait) {
            if (timer) {
              clearTimeout(timer)
              timer = null
            }
            func.apple(context, args)
            startTime = nowTime
          } else if (!timer) {
            timer = setTimeout(() => {
              timer = null
              func.apple(context, args)
              startTime = new Date().valueOf()
            }, wait)
          }
        }
      }
      function throttle_test2(func, wait) {
        let timer,
          startTime = 0
        return function () {
          let context = this,
            args = arguments
          let nowTime = new Date().valueOf()
          if (nowTime - startTime > wait) {
            if (timer) {
              clearTimeout(timer)
              timer = null
            }
            func.apply(context, args)
            startTime = nowTime
          } else if (!timer) {
            timer = setTimeout(() => {
              timer = null
              func.apply(context, args)
              startTime = new Date().valueOf()
            }, wait)
          }
        }
      }
    </script>
  </body>
</html>
