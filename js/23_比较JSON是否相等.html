<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>比较两个JSON文件是否相等</title>
  </head>
  <body>
    <div id="test"></div>
    <script type="text/javascript">
      const log = console.log
      function isObj(object) {
        return object && typeof(object) == 'object' && Object.prototype.toString.call(object).toLowerCase() == "[object object]";
      }
      function isArray(object) {
        return object && typeof(object) == 'object' && object.constructor == Array;
      }
      function getLength(object) {
        var count = 0;
        for (var i in object) count++;
        return count;
      }
      function compare(objA, objB) {
        if (!isObj(objA) || !isObj(objB)) return false; //判断类型是否正确
        if (getLength(objA) != getLength(objB)) return false; //判断长度是否一致
        return compareObj(objA, objB, true); //默认为true
      }
      function compareObj(objA, objB, flag) {
        for (var key in objA) {
          if (!flag) //跳出整个循环
          break;
          if (!objB.hasOwnProperty(key)) {
            flag = false;
            break;
          }
          if (!isArray(objA[key])) { //子级不是数组时,比较属性值
            if (objB[key] != objA[key]) {
              flag = false;
              break;
            }
          } else {
            if (!isArray(objB[key])) {
              flag = false;
              break;
            }
            var oA = objA[key],
            oB = objB[key];
            if (oA.length != oB.length) {
              flag = false;
              break;
            }
            for (var k in oA) {
              if (!flag) //这里跳出循环是为了不让递归继续
              break;
              flag = compareObj(oA[k], oB[k], flag);
            }
          }
        }
        return flag;
      }
          var jsonObjA = []
          var jsonObjB = []

      var result = compare(jsonObjA, jsonObjB);
      console.log(result); // true or false

      // Warn if overriding existing method
      if(Array.prototype.equals)
        console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
      // attach the .equals method to Array's prototype to call it on any array
      Array.prototype.equalsa = function (array) {
        // if the other array is a falsy value, return
        if (!array)
          return false;
        // compare lengths - can save a lot of time 
        if (this.length != array.length)
          return false;
        for (var i = 0, l = this.length; i < l; i++) {
          // Check if we have nested arrays
          if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
              return false;    
          }      
          else if (this[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;  
          }      
        }    
        return true;
      }
      // Hide method from for-in loops
      Object.defineProperty(Array.prototype, "equals", {enumerable: false});
      const a = [{

      }];
      const b = [{
        a: {}
      }];
      (function(){
  console.log("asdfasdfasdfasd");
      // attach the .equals method to Array's prototype to call it on any array
      Array.prototype.equalsa = function (array) {
        // if the other array is a falsy value, return
        if (!array)
          return false;
        // compare lengths - can save a lot of time 
        if (this.length != array.length)
          return false;
        for (var i = 0, l = this.length; i < l; i++) {
          // Check if we have nested arrays
          if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
              return false;    
          }      
          else if (this[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;  
          }      
        }    
        return true;
      }
      // Hide method from for-in loops
      Object.defineProperty(Array.prototype, "equals", {enumerable: false});
})()
      console.log("a.equalsa(b)",a.equalsa(b));


      const initAreaParamsComparator = () => {
      //对象比较方法
      Object.prototype.comparisonAreaEditorParamsObj = (object2) => {
        //For the first loop, we only check for types
        for (propName in this) {
          //Check for inherited methods and properties - like .equals itself
          //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
          //Return false if the return value is different
          if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) {
            return false;
          }
          //Check instance type
          else if (typeof this[propName] != typeof object2[propName]) {
            //Different types => not equal
            return false;
          }
        }
        //Now a deeper check using other objects property names
        for(propName in object2) {
          //We must check instances anyway, there may be a property that only exists in object2
            //I wonder, if remembering the checked values from the first loop would be faster or not 
          if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) {
            return false;
          }
          else if (typeof this[propName] != typeof object2[propName]) {
            return false;
          }
          //If the property is inherited, do not check any more (it must be equa if both objects inherit it)
          if(!this.hasOwnProperty(propName))
           continue;
      
          //Now the detail check and recursion
      
          //This returns the script back to the array comparing
          /**REQUIRES Array.equals**/
          if (this[propName] instanceof Array && object2[propName] instanceof Array) {
                // recurse into the nested arrays
            if (!this[propName].comparisonAreaEditorParamsObj(object2[propName]))
                  return false;
          }
          else if (this[propName] instanceof Object && object2[propName] instanceof Object) {
                // recurse into another objects
                //console.log("Recursing to compare ", this[propName],"with",object2[propName], " both named \""+propName+"\"");
            if (!this[propName].comparisonAreaEditorParamsObj(object2[propName]))
                  return false;
          }
          //Normal value comparison for strings and numbers
          else if(this[propName] != object2[propName]) {
            return false;
          }
        }
        //If everything passed, let's say YES
        return true;
      }

    // attach the .equals method to Array's prototype to call it on any array
    Array.prototype.comparisonAreaEditorParamsArray = (array) => {
        // if the other array is a falsy value, return
        if (!array)
          return false;
        // compare lengths - can save a lot of time 
        if (this.length != array.length)
          return false;
        for (var i = 0, l = this.length; i < l; i++) {
          // Check if we have nested arrays
          if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].comparisonAreaEditorParamsObj(array[i]))
              return false;    
          }      
          else if (this[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;  
          }      
        }    
        return true;
      }
      // Hide method from for-in loops
      Object.defineProperty(Array.prototype, "comparisonAreaEditorParamsArray", {enumerable: false});
      
}




  
    </script>
  </body>
</html>
